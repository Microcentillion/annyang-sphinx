(function undefined() {
   "use strict";
   
   var debug = true;
   
   
   // These will be initialized later
   var root = this;
   var recognizer, recorder, callbackManager, audioContext, vizualizer;
   // Only when both recorder and recognizer do we have a ready application
   var readyCallback = false;
   var hypCallback = false;
   var wordlist;
   
   var state = {
      init: false,
      recorder: {
         initialized: false,
         isConsuming: false
      },
      recognizer: {
         defined: false,
         initialized: false,
         isConsumed: false,
         hasWords: false,
         hasGrammar: false
      },
      annsphinx: {
         ready: false,
         listening: false
      }
   }
   
   var spawnWorker = function (workerURL, callback) {
      if (debug) console.log('Spawning new worker');
      recognizer = new Worker(workerURL);
      state.recognizer.defined = true;
      recognizer.onmessage = function(event) {
         callback(recognizer);
      };
      
      recognizer.postMessage('');
   }
   
   var initRecognizer = function(callback) {
      if (debug) console.log('Initializing recognizer');
      postRecognizerJob({command: 'initialize'}, function() {
         if (recorder) {
            recorder.consumers = [recognizer];
            state.recognizer.isConsumed = true;
            state.recorder.isConsuming = true;
            if (debug) console.log('Recognizer consumed');
         }
         
         if (debug) console.log('Recognizer loaded');
         state.recognizer.initialized = true;
         if (state.recognizer.hasWords !== false && state.recognizer.hasWords !== true) annsphinx.addWords(state.recognizer.hasWords);
         if (state.recognizer.hasGrammar !== false && state.recognizer.hasGrammar !== true) annsphinx.addGrammar(state.recognizer.hasGrammar);
         
         checkReady();
      });
   }
   
   var makeReady = function () {
      isReady = true;
   }
   
   var recognizerReady = function () {
      for (var i in state.recognizer) {
         if (state.recognizer[i] !== true) return false;
      }
      
      return true;
   }
   
   var recorderReady = function () {
      for (var i in state.recorder) {
         if (state.recorder[i] !== true) return false;
      }
      
      return true;
   }   
   
   var checkReady = function () {
      if (recognizerReady() == true && recorderReady() == true) {
         if (!state.annsphinx.ready) {
            if (debug) console.log('Annsphinx is loaded and ready.');
            state.annsphinx.ready = true;
            if (readyCallback) readyCallback();
         }
      } else {
         if (recognizerReady() != true && debug) console.log('Annsphinx waiting on recognizer');
         if (recorderReady() != true && debug) console.log('Annsphinx waiting on recorder');
      }
   }
   
   var startUserMedia = function (stream) {
      var input = audioContext.createMediaStreamSource(stream);
      // Firefox hack https://support.mozilla.org/en-US/questions/984179
      window.firefox_audio_hack = input; 
      var audioRecorderConfig = {errorCallback: function(x) {console.log("** Error from recorder: " + x);}}; // Status change
      recorder = new AudioRecorder(input, audioRecorderConfig);
      state.recorder.initialized = true;
      
      // If a recognizer is ready, we pass it to the recorder
      if (recognizer && !state.recognizer.isConsumed) {
         recorder.consumers = [recognizer];
         state.recognizer.isConsumed = true;
         state.recorder.isConsuming = true;
         if (debug) console.log('Recognizer consumed');
      }
      
      if (debug) console.log('Recorder initialized');
      checkReady();
   }
   
   var postRecognizerJob = function (message, callback) {
      var msg = message || {};
      if (callbackManager) {
         msg.callbackId = callbackManager.add(callback);
      }
      
      if (recognizer) {
         recognizer.postMessage(msg);
      }
   }
   
   root.annsphinx = {
   
      init: function(notify) {
         callbackManager = new CallbackManager();
         spawnWorker("js/recognizer.js", function(worker) {
            
            // This is the onmessage function, once the worker is fully loaded
            worker.onmessage = function(e) {
               if (debug) console.log(e);
               // This is the case when we have a callback id to be called
               if (e.data.hasOwnProperty('id')) {
                  var clb = callbackManager.get(e.data['id']);
                  var data = {};
                  
                  if (e.data.hasOwnProperty('data')) {   // If there are parameters of the callback
                     data = e.data.data;                 // Add them
                  }

                  if(clb) {                         // If the callback exists
                     clb(data);                     // call it with its data.
                  }
               }
                  
                  // This is a case when the recognizer has a new hypothesis
               if (e.data.hasOwnProperty('hyp')) {
                  var newHyp = e.data.hyp;
                  if (e.data.hasOwnProperty('final') &&  e.data.final) {      // If the data is Final
                     newHyp = "Final: " + newHyp;                             // Say so
                  }
                  
                  // do something with the hypothesis
                  if (hypCallback) {
                     hypCallback(newHyp);
                  } else {
                    if (debug) console.log(newHyp);
                  }
               }
               // This is the case when we have an error
               if (e.data.hasOwnProperty('status') && (e.data.status == "error")) {
                  console.log("** Error in " + e.data.command + " with code " + JSON.stringify(e.data.code));
               }
            },            
            // Once the worker is fully loaded, we can call the initialize function
            initRecognizer();
         });
         
         try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            window.URL = window.URL || window.webkitURL;
            audioContext = new AudioContext();
            if (notify) notify({success: 1});
            
         } catch (e) {
            if (notify) notify({error: 'Error initializing audio in browser'});
         }

         if (navigator.getUserMedia) {
            navigator.getUserMedia({audio: true}, startUserMedia, function(e) {
               if (notify) notify({error: 'No input available'});
            });
            
         } else {
            if (notify) notify({error: 'Live audio not supported in this browser'});
         }
         
         return this;
      },
      
      addListenCallback: function (callback) {
         if (callback) listenCallback = callback;
         return this;
      },
      
      addHypCallback: function (callback) {
         if (callback) hypCallback = callback;
         return this;
      },
      
      addConsumer: function (consumer) {
         if (recognizerReady && recorderReady) recorder.consumers = [consumer];
         return this;
      },
      
      start: function(callback) {
         if (recorder && recorder.start() && callback) {
            state.annsphinx.listening = true;
            callback();
         } else {
            console.log(recorder);
         }
         
         return this;
      },
      
      stop: function (callback) {
         if (recorder && recorder.stop() && callback) {
            state.annsphinx.listening = false;
            callback();
         } else {
            console.log(recorder);
         }
         return this;
      },
      
      addWords: function (words, append, callback) {
         if (append) {
            wordlist = wordlist.concat(words);
         } else {
            wordlist = words;
         }
         
         if (state.recognizer.initialized == true) {
            postRecognizerJob({command: 'addWords', data: wordlist}, function () {
               state.recognizer.hasWords = true;

               if (debug) console.log('words added');
            });
            
            if (callback) callback();
         } else {
         
            state.recognizer.hasWords = wordlist;
            if (debug) console.log('words queued');
            if (callback) callback();
         }
         
         return this;
      },
      
      addGrammar: function (grammar, callback) {
         if (state.recognizer.initialized == true) {
            postRecognizerJob({command: 'addGrammar', data: grammar}, function () {
               state.recognizer.hasGrammar = true;

               if (debug) console.log('grammar added');
            });

            if (callback) callback()
         } else {
         
            state.recognizer.hasGrammar = grammar;
            if (debug) console.log('grammar queued');
            if (callback) callback();
         }
         return this;
      },
      
      onReady: function (callback) {
         if (state.annsphinx.ready) {
            callback();
         } else {
            readyCallback = callback;
         }
         
         return this;
      }
   };
}).call(this);
